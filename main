#!/usr/bin/env python3

from datetime import datetime, timezone
from dateutil import tz
from scapy.all import *
from threading import Thread
from pprint import pprint
import argparse
import csv
import dateutil.parser
import gps
import os
import sqlite3
import time

# Init tracking table for tracking seen APs and improving results with superior RSSIs
sessionTracking = {}

# Init gpsData
gpsData = { "gpsTimestamp": None, "gpsTimestampAge": None, "Longitude": None, "Latitude": None }
# Longitude/Latitude   The location data received at gpsTimestamp.
# gpsTimestamp     The timestamp with that Lon / Lat from GPS
# gpsTimestampAge  The difference in seconds between your host's time and the gpsTimestamp stamp.
#                      Useful to know if your GPS has lost its lock when writing results.


parser = argparse.ArgumentParser()
parser.add_argument("--dbfile",  default='',  help="Enter a relative or full filepath. If not provided a default will be used.")
parser.add_argument("--interface", default='',  help="Interface of choice")
parser.add_argument("--disablechannelswitching", default=False, action='store_true', help="Assume another program is already handling channel switching. We're just along for the ride.")
parser.add_argument("--importcsv", default='', help="CSV file to import")
parser.add_argument("--google", default='', action='store_true', help="Break CSV export into multiple files of 2000 data point each. For Google's 'My Maps' which has a 2000-per-csv limit.")

args = parser.parse_args()

#   ____ _
#  / ___| | __ _ ___ ___  ___  ___
# | |   | |/ _` / __/ __|/ _ \/ __|
# | |___| | (_| \__ \__ \  __/\__ \
#  \____|_|\__,_|___/___/\___||___/
#

class Database: # Our database object
  def __init__(self, databaseFile):
    try:
      self.con = sqlite3.connect(databaseFile,check_same_thread=False)
      self.cur = self.con.cursor()
        # Create our database and a duplicate for evicted(Deemed less accurate) datapoints
      self.exec("create table if not exists wifi \
             (bssid VARCHAR(17),ssid,channel INT,security TEXT,rssi INT,timestamp INT,timestampAge REAL,lat REAL,lon REAL, unique (bssid))")
      self.exec("create table if not exists wifi_evicted \
             (bssid VARCHAR(17),ssid,channel INT,security TEXT,rssi INT,timestamp INT,timestampAge REAL,lat REAL,lon REAL)")
    except Exception as e:
      print('Failed to prepare Database: ', e)
    finally:
      print('Database Connected')

  def exec(self, query):
    #print('DEBUG: This is the query:' + query)
    self.cur.execute(query)
    self.con.commit()

  def checkBssidExists(self,bssid): # Check if we have a point for a given BSSID already.
    self.exec("select * from wifi where bssid = '%s' limit 1" %(bssid))
    result = self.cur.fetchone()
    if result: # Truthy check for whether we got any result at all.
      #print('BSSID Exists in database already')
      return(result)
    else:
      #print('BSSID is new')
      return(False)

  def checkNewPointBetter(self,storeCheck,bssid,ssid,rssi,channel,security,timestamp,timestampAge,lat,lon): # Check if we're replacing stored data.
    if int(rssi) > storeCheck[2]:
      #print('rssi improved')
      return(True)
    else:
      #print('No RSSI improvement, leaving alone.')
      return(False)

  def retirePoint(self,bssid):
    self.exec("INSERT OR REPLACE INTO wifi_evicted select * from wifi where bssid = '%s'" %(bssid))
    self.exec("DELETE from wifi where bssid = '%s'" %(bssid))

  def writePoint(self,bssid,ssid,rssi,channel,security,timestamp,timestampAge,lat,lon):
    ssid = ssid.replace("'","''")
    self.exec("insert or ignore into wifi values ('%s','%s','%s','%s','%s','%s','%s','%s','%s')" %(bssid,ssid,rssi,channel,security,timestamp,timestampAge,lat,lon))

  def handleWifiPoint(self,bssid,ssid,rssi,channel,security,timestamp,timestampAge,lat,lon):
    storeCheck = self.checkBssidExists(bssid)
    if storeCheck:
        if self.checkNewPointBetter(storeCheck,bssid,ssid,rssi,channel,security,timestamp,timestampAge,lat,lon):
          self.retirePoint(bssid)
          self.writePoint(bssid,ssid,rssi,channel,security,timestamp,timestampAge,lat,lon)
    else:
      #print('Writing new point: ' + bssid)
      self.writePoint(bssid,ssid,rssi,channel,security,timestamp,timestampAge,lat,lon)



# _____                 _   _
#|  ___|   _ _ __   ___| |_(_) ___  _ __  ___
#| |_ | | | | '_ \ / __| __| |/ _ \| '_ \/ __|
#|  _|| |_| | | | | (__| |_| | (_) | | | \__ \
#|_|   \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
#

def date2unix(date):
  if type(date) == int: # If already a number, assume it's already a unix timestamp
    return(date)
  else: # Otherwise, try reading it
    try:
      result = str(dateutil.parser.parse(date).timestamp()).split('.')[0]
    except:
      return(False)
    finally:
      return(result)

def importcsv(args):
  if os.path.isfile(args.importcsv):
    with open(args.importcsv) as csvfile:
      reader = csv.DictReader(csvfile)
      for row in reader:
        if row['bssid'] and row['ssid'] and row['Latitude'] and row['Longitude']: # Check for these during import at a minimum

          print('Importing: ' + row['bssid'] + ' to our database.')

          if row['gpsTimestamp']: # Convert the timestamp to UNIX
            try:
              gpsTimestamp = date2unix(row['gpsTimestamp'])
            except:
              print('Failed to convert date...')
              gpsTimestamp = row['gpsTimestamp']

          db.handleWifiPoint(row['bssid'],row['ssid'],row['rssi'],row['channel'],row['security'],row['gpsTimestamp'],row['gpsTimestampAge'],row['Latitude'],row['Longitude'])

        else:
          print('Failed to import: ' + row['bssid'] + '/' + row['ssid'] + ' to our database.')
          print('We need at least bssid,ssid,Latitude,Longitide to import to the database. If this datapoint has all of these, please check your CSV has no errors!')

  else:
    print('Argument given is not a file')
    exit(1)

  exit(0)

def gpsThread(): # Generate GPS data for other threads.
  session = gps.gps(mode=gps.WATCH_ENABLE)
  global gpsData

  while True:
    while 0 == session.read():
      if not (gps.MODE_SET & session.valid): continue

      time=lat=lon=None

      if gps.TIME_SET & session.valid:
        time = session.fix.time
      else: time = None

      if ((gps.isfinite(session.fix.latitude) and gps.isfinite(session.fix.longitude))):
        lat = session.fix.latitude
        lon = session.fix.longitude
      else:
        lat=lon=None

      if time and lat and lon:
        gpsData["gpsTimestamp"] = time
        gpsData["Latitude"]     = lat
        gpsData["Longitude"]    = lon

      # Update drift seconds on stored gpsData
      if gpsData['gpsTimestamp']:
        gpsTime = datetime.strptime(str(gpsData['gpsTimestamp']),'%Y-%m-%dT%H:%M:%S.%f%z')
        gpsTime = gpsTime.replace(tzinfo=tz.tzutc()).astimezone(tz=tz.tzlocal())
        localTime = datetime.now().astimezone()
        gpsData["gpsTimestampAge"] = ((localTime-gpsTime).total_seconds())

    time.sleep(1) # One second sleep between polls should be fine. Make this a variable however. And add arguments to the script.

def processPacket(packet):
  global sessionTracking

  try:
    if packet.haslayer(Dot11Beacon): # If the packet looks good, proceed
      bssid = packet[Dot11].addr2
      ssid  = packet[Dot11Elt].info.decode().rstrip('\x00')
      if len(ssid) == 0: ssid = "<Hidden>"
      rssi = packet.dBm_AntSignal
  
      stats = packet[Dot11Beacon].network_stats()
      channel  = stats.get("channel")
      security = ''.join(stats.get("crypto"))
      
      # Handle new and seen APs. 
      # If new:  Add to array.
      # If seen: Compare RSSI, GPS Coordinates if better.
      
      if not bssid in sessionTracking:
        #print('New: ',bssid, ssid, channel, security,rssi)
        db.handleWifiPoint(bssid,ssid,rssi,channel,security,gpsData['gpsTimestamp'],gpsData['gpsTimestampAge'],gpsData['Latitude'],gpsData['Longitude'])


  except Exception as e: # Ignore busted packets
    print(e)
    pass

def snifferThread():
  sniff(prn=processPacket, iface=interface)


def channelSwitcher():
  print('Channel switching thread started')
  ch = 1
  while True:
    os.system(f"iwconfig {interface} channel {ch}")
    # switch channel from 1 to 14 each 0.5s
    ch = ch % 14 + 1
    time.sleep(0.25)

def waitForGPSLock():
  print('Waiting for GPS lock...')
  while True:
    time.sleep(1)
    if gpsData["gpsTimestamp"] is not None:
      print("Got it:" + str(list(gpsData.values())))
      break

def writeCsv(dbfile):
  global sessionTracking
  global args

  try:
    firstElement = next(iter(sessionTracking))

    with open(dbfile, 'w') as csvFile:
      subKey = list(sessionTracking.keys())[0]
      w = csv.DictWriter(csvFile, sessionTracking[subKey].keys()) # Use first key as CSV formatter for all keys
      w = csv.writer(csvFile)

      w.writerow(sessionTracking[firstElement]) # Use the first element as our CSV header key.

      for AP in list(sessionTracking.keys()): # Loop over all APs and write each to the CSV.
        w.writerow(list(sessionTracking[AP].values()))
  except:
    pass

#  ____
# / ___| ___
#| |  _ / _ \
#| |_| | (_) |
# \____|\___/
#

# We assume bettercap will handle channel switching.

if __name__ == "__main__":
  scriptRoot = os.path.dirname(os.path.realpath(__file__))
  databaseFile = scriptRoot + '/wifi.db'

  db = Database(databaseFile)

  if args.importcsv:
    importcsv(args)

  if args.interface == '':
    print('We need a --interface to work with!')
    parser.print_help()
    exit(1)

  interface = args.interface
  gpsThread = Thread(target=gpsThread)
  gpsThread.daemon = True
  gpsThread.start()

  waitForGPSLock()

  snifferThread = Thread(target=snifferThread)
  snifferThread.daemon = True
  snifferThread.start()

  if not args.disablechannelswitching:
    channelSwitcher = Thread(target=channelSwitcher)
    channelSwitcher.daemon = True
    channelSwitcher.start()

  if args.dbfile == '':
    now = datetime.now().strftime("%Y-%m-%d_%H:%M:%S%z")
    dbfile = "./wifigps." + now + ".csv"
    print('Writing to default: ' + dbfile)
  else:
    print('Writing to custom file: ' + args.dbfile)
    dbfile = args.dbfile

  print('Collecting...')

  while True:
    time.sleep(1) # Wait to be killed while threads work their magic.
