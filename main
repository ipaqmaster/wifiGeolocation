#!/usr/bin/env python3

from datetime import datetime, timezone
from dateutil import tz
from scapy.all import *
from threading import Thread
from pprint import pprint
import atexit
import argparse
import csv
import dateutil.parser
import gps
import os
import sqlite3
import time

parser = argparse.ArgumentParser()
parser.add_argument("--interface", default='',  help="Interface of choice")
parser.add_argument("--nomanagement", default=False, action='store_true', help="Assume another program is already handling int setup/restoration and channel switching. We're just along for the ride.")
parser.add_argument("--importcsv", default='', help="CSV file to import")
parser.add_argument("--exportcsv", default='', help="CSV filename to export with. If --google used this is a basename and CSVs get saved to your CWD")
parser.add_argument("--google", default='', action='store_true', help="Break CSV export into multiple files of 2000 data point each. For Google's 'My Maps' which has a 2000-per-csv limit.")
parser.add_argument("--skipgps", default='', action='store_true', help="Don't wait for GPS info. For developing this script without a GPS present.")
parser.add_argument("--debug", default='', action='store_true', help="Makes the script print more during runtime.")

args = parser.parse_args()

#   ____ _
#  / ___| | __ _ ___ ___  ___  ___
# | |   | |/ _` / __/ __|/ _ \/ __|
# | |___| | (_| \__ \__ \  __/\__ \
#  \____|_|\__,_|___/___/\___||___/
#

class Database: # Our database object
  def __init__(self, databaseFile):
    try:
      self.con = sqlite3.connect(databaseFile,check_same_thread=False)
      self.cur = self.con.cursor()
        # Create our database and a duplicate for evicted(Deemed less accurate) datapoints
      self.exec("create table if not exists wifi \
             (bssid VARCHAR(17),ssid,channel INT,security TEXT,rssi INT,timestamp INT,timestampAge REAL,lat REAL,lon REAL, unique (bssid))")
      self.exec("create table if not exists wifi_evicted \
             (bssid VARCHAR(17),ssid,channel INT,security TEXT,rssi INT,timestamp INT,timestampAge REAL,lat REAL,lon REAL)")
    except Exception as e:
      print('Failed to prepare Database: ', e)
    finally:
      print('Database Connected')

  def exec(self, query):
    #printDebug('DEBUG: This is the query:' + query)
    self.cur.execute(query)
    self.con.commit()

  def execFetchAll(self, query):
    self.exec(query)
    return(self.cur.fetchall())

  def checkBssidExists(self,bssid): # Check if we have a point for a given BSSID already.
    self.exec("select * from wifi where bssid = '%s' limit 1" %(bssid))
    result = self.cur.fetchone()
    if result: # Truthy check for whether we got any result at all.
      #printDebug('BSSID Exists in database already')
      return(result)
    else:
      #printDebug('BSSID is new')
      return(False)

  def checkNewPointBetter(self,storeCheck,bssid,ssid,rssi,channel,security,timestamp,timestampAge,lat,lon): # Check if we're replacing stored data.
    if int(rssi) > storeCheck[2]:
      #printDebug('RSSI improved')
      return(True)
    else:
      #printDebug('No RSSI improvement, leaving alone.')
      return(False)

  def retirePoint(self,bssid):
    self.exec("INSERT OR REPLACE INTO wifi_evicted select * from wifi where bssid = '%s'" %(bssid))
    self.exec("DELETE from wifi where bssid = '%s'" %(bssid))

  def writePoint(self,bssid,ssid,rssi,channel,security,timestamp,timestampAge,lat,lon):
    if args.skipgps:
      print('Skipping point write due to --skipgps: ' + bssid + ' ' + ssid)
    else:
      ssid = ssid.replace("'","''")
      self.exec("insert or ignore into wifi values ('%s','%s','%s','%s','%s','%s','%s','%s','%s')" %(bssid,ssid,rssi,channel,security,timestamp,timestampAge,lat,lon))

  def handleWifiPoint(self,bssid,ssid,rssi,channel,security,timestamp,timestampAge,lat,lon):
    storeCheck = self.checkBssidExists(bssid)
    if storeCheck:
        if self.checkNewPointBetter(storeCheck,bssid,ssid,rssi,channel,security,timestamp,timestampAge,lat,lon):
          printDebug('Updating point: ' + bssid + ' Staleness: ' + str(timestampAge))
          self.retirePoint(bssid)
          self.writePoint(bssid,ssid,rssi,channel,security,timestamp,timestampAge,lat,lon)
    else:
        printDebug('Writing new point: ' + bssid + ' Staleness: ' + str(timestampAge))
        self.writePoint(bssid,ssid,rssi,channel,security,timestamp,timestampAge,lat,lon)



# _____                 _   _
#|  ___|   _ _ __   ___| |_(_) ___  _ __  ___
#| |_ | | | | '_ \ / __| __| |/ _ \| '_ \/ __|
#|  _|| |_| | | | | (__| |_| | (_) | | | \__ \
#|_|   \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
#

def cleanup():
  print('Cleaning up...')
  manageInt(args,'managed')

def printDebug(content):
  if args.debug:
    print('DEBUG: ' + content)

def date2unix(date):
  if type(date) == int: # If already a number, assume it's already a unix timestamp
    return(date)
  else: # Otherwise, try reading it
    try:
      result = str(dateutil.parser.parse(date).timestamp()).split('.')[0]
    except:
      return(False)
    finally:
      return(int(result))

def importCsv(args):
  if os.path.isfile(args.importcsv):
    with open(args.importcsv) as csvfile:
      reader = csv.DictReader(csvfile)
      for row in reader:
        if row['bssid'] and row['ssid'] and row['Latitude'] and row['Longitude']: # Check for these during import at a minimum

          print('Importing: ' + row['bssid'] + ' to our database.')

          if row['gpsTimestamp']: # Convert the timestamp to UNIX
            try:
              gpsTimestamp = date2unix(row['gpsTimestamp'])
            except:
              print('Failed to convert date...')
              gpsTimestamp = row['gpsTimestamp']

          db.handleWifiPoint(row['bssid'],row['ssid'],row['rssi'],row['channel'],row['security'],gpsTimestamp,row['gpsTimestampAge'],row['Latitude'],row['Longitude'])

        else:
          print('Failed to import: ' + row['bssid'] + '/' + row['ssid'] + ' to our database.')
          print('We need at least bssid,ssid,Latitude,Longitide to import to the database. If this datapoint has all of these, please check your CSV has no errors!')

  else:
    print('Argument given is not a file')
    exit(1)

  exit(0)

def exportCsv(args):
  headerQuery = db.execFetchAll('PRAGMA table_info(wifi)')
  headers = []
  for column in headerQuery: # Put headers together for the csv.
    headers.append(column[1])

  wifiQuery = db.execFetchAll('select * from wifi')

  with open(args.exportcsv, 'w') as csvFile:
    w = csv.DictWriter(csvFile, headers)
    w = csv.writer(csvFile)

      # We can either select the data out converting the timestamp row (select datetime(timestamp, 'auto')) for example
      # Or we can take the tuple row here and convert it in python to a local timezone. This would easily specify the +TZ as well.
      # e.g. date = print(time.replace(tzinfo=tz.tzutc()).astimezone(tz=tz.tzlocal()))
      # Make a unix2date function?
    w.writerow(headers)   # Write the header
    for row in wifiQuery: # Write the data
      w.writerow(row)
  exit(0)


def gpsThread(): # Generate GPS data for other threads.
  session = gps.gps(mode=gps.WATCH_ENABLE)
  global gpsData

  while True:
    while 0 == session.read():
      if not (gps.MODE_SET & session.valid): continue

      time=lat=lon=None

      if gps.TIME_SET & session.valid:
        time = session.fix.time
      else: time = None

      if ((gps.isfinite(session.fix.latitude) and gps.isfinite(session.fix.longitude))):
        lat = session.fix.latitude
        lon = session.fix.longitude
      else:
        lat=lon=None

      if time and lat and lon:
        gpsData["gpsTimestamp"] = time
        gpsData["Latitude"]     = lat
        gpsData["Longitude"]    = lon

      # Update drift seconds on stored gpsData
      if gpsData['gpsTimestamp']:
        gpsTime = datetime.strptime(str(gpsData['gpsTimestamp']),'%Y-%m-%dT%H:%M:%S.%f%z')
        gpsTime = gpsTime.replace(tzinfo=tz.tzutc()).astimezone(tz=tz.tzlocal())
        localTime = datetime.now().astimezone()
        gpsData["gpsTimestampAge"] = ((localTime-gpsTime).total_seconds())

    time.sleep(1) # One second sleep between polls should be fine. Make this a variable however. And add arguments to the script.

def processPacket(packet):
  try:
    if packet.haslayer(Dot11Beacon): # If the packet looks good, proceed
      bssid = packet[Dot11].addr2
      ssid  = packet[Dot11Elt].info.decode().rstrip('\x00')
      if len(ssid) == 0: ssid = "<Hidden>"
      rssi = packet.dBm_AntSignal
  
      stats = packet[Dot11Beacon].network_stats()
      channel  = stats.get("channel")
      security = ''.join(stats.get("crypto"))
      
      # Handle new and seen APs. 
      # If new:  Add to array.
      # If seen: Compare RSSI, GPS Coordinates if better.
      
      #printDebug('Processing: ',bssid, ssid, channel, security,rssi)
      db.handleWifiPoint(bssid,ssid,rssi,channel,security,gpsData['gpsTimestamp'],gpsData['gpsTimestampAge'],gpsData['Latitude'],gpsData['Longitude'])

  except Exception as e: # Ignore busted packets
    print('Packet issue: ' + str(e))
    pass

def executeCmd(cmd):
  try: 
    subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True, shell=True)
  except subprocess.CalledProcessError as e:
    print('Command [' + cmd + '] failed: ' + e.stderr.decode("utf-8"))

def manageInt(args,mode):
  if args.nomanagement:
    print('--nomanagement specified, not touching ' + args.interface)
    return
  if mode == 'monitor':
    txmode = 'fixed 3000'
  elif mode == 'managed':
    txmode = 'auto'

  try:
    executeCmd('ip link set ' + args.interface + ' down')
    executeCmd('iw ' + args.interface + ' set type ' + mode)
    executeCmd('ip link set ' + args.interface + ' up')
    # Not all interfaces like being told to go into auto
    executeCmd('iw ' + args.interface + ' set txpower ' + txmode)
  except Exception as e:
    print('Something went wrong prepping interface: ' + args.interface)
    print(e)
  finally:
    print(args.interface + ' is now a ' + mode + ' interface.')


def snifferThread(args):
  try:
    sniff(prn=processPacket, iface=args.interface)
  except PermissionError:
    print('No access to interface ' + args.interface + ' Please give this user access or run the script as root.')
    exit(1)
  except Exception as e:
    print('Interface trouble: ' + str(e))
    exit(1)

def channelSwitcher():
  print('Channel switching thread started...')
  ch = 1
  while True:
    executeCmd('iwconfig {interface} channel {ch}'.format(interface = args.interface, ch = ch))
    ch = ch % 14 + 1
    time.sleep(0.25)

def waitForGPSLock(args):
  if args.skipgps:
    gpsData['gpsTimestamp']    = 'NA';
    gpsData['gpsTimestampAge'] = 'NA';
    gpsData['Latitude']        = 0;
    gpsData['Longitude']       = 0;
    print("Skipping GPS wait and setting dummy values: " + str(list(gpsData.values())))
  else:
    print('Waiting for GPS lock...')
    while True:
      time.sleep(1)
      if gpsData["gpsTimestamp"] is not None:
        print("Got it: " + str(list(gpsData.values())))
        break

#  ____
# / ___| ___
#| |  _ / _ \
#| |_| | (_) |
# \____|\___/
#

if __name__ == "__main__":
  scriptRoot = os.path.dirname(os.path.realpath(__file__))
  databaseFile = scriptRoot + '/wifi.db'

  db = Database(databaseFile)

  if args.importcsv:
    importCsv(args)

  if args.exportcsv:
    exportCsv(args)

  printDebug('Debugging is enabled.')

  if args.interface == '':
    print('We need a --interface to work with!')
    parser.print_help()
    exit(1)

  # Init gpsData
  gpsData = { "gpsTimestamp": None, "gpsTimestampAge": None, "Longitude": None, "Latitude": None }
  # Longitude/Latitude   The location data received at gpsTimestamp.
  # gpsTimestamp     The timestamp with that Lon / Lat from GPS
  # gpsTimestampAge  The difference in seconds between your host's time and the gpsTimestamp stamp.
  #                      Useful to know if your GPS has lost its lock when writing results.

  gpsThread = Thread(target=gpsThread)
  gpsThread.daemon = True
  gpsThread.start()

  waitForGPSLock(args)

  manageInt(args,'monitor')
  atexit.register(cleanup)

  if not args.nomanagement:
    channelSwitcher = Thread(target=channelSwitcher)
    channelSwitcher.daemon = True
    channelSwitcher.start()

  print('Beginning recon...')
  snifferThread = Thread(target=snifferThread(args))
  snifferThread.daemon = True
  snifferThread.start()

